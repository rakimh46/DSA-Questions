https://leetcode.com/problems/minimize-malware-spread-ii/
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        UnionFind uf = new UnionFind(n);
        
        Set<Integer> set=new HashSet<>();
        for(int u:initial){
            set.add(u);
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1 && !set.contains(i) && !set.contains(j)) {
                    uf.union(i, j); //make union without infected node
                }
            }
        }
        
        Map<Integer,HashSet<Integer>> map=new HashMap<>();
        int[]infected=new int[n];  
        
        for(int u: initial){
            map.put(u,new HashSet<>()); // get all infected near parent node
            for(int j=0;j<n;j++){
                if(graph[u][j]==1 && u!=j && !set.contains(j)){
                    int p=uf.find(j);
                    if(!map.get(u).contains(p)){
                        infected[p]++;
                        map.get(u).add(p);
                    }
                }
            }
        }
        
        int ans=-1;
        int max=-1;
        for(int u:initial){
            HashSet<Integer> pars=map.get(u);
            int total=0;
            for(int p: pars){
                if(infected[p]==1){
                    total+=uf.size[p];
                }
            }
            
            if(total>=max){
                if(total==max){
                    ans=Math.min(ans,u);
                }else{
                    ans=u;
                }
                max=total;
            }
            
        }
        
        if(ans==-1){
            return initial[0];
        }
        return ans;
    }
    
    class UnionFind {
        int par[];
        int size[];

        UnionFind(int vtx) {
            par = new int[vtx];
            size = new int[vtx];
            for (int i = 0; i < vtx; i++) {
                par[i] = i;
                size[i] = 1;
            }
        }

        void union(int v1, int v2) {
            int rt1 = find(v1);
            int rt2 = find(v2);

            if (rt1 != rt2) {
                if (size[rt1] >= size[rt2]) {
                    par[rt2] = rt1;
                    size[rt1] += size[rt2];
                } else if (size[v1] < size[rt2]) {
                    par[rt1] = rt2;
                    size[rt2] += size[rt1];;
                }
            }
        }

        int find(int vtx) {
            if (par[vtx] == vtx) {
                return vtx;
            }
            return par[vtx] = find(par[vtx]);
        }
    }

}
